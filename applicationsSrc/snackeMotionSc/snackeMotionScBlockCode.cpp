
/**
 * @file myAppMotionSCCode.cpp
 * Generated by VisibleSim BlockCode Generator
 * https://services-stgi.pu-pm.univ-fcomte.fr/visiblesim/generator.php#
 * @author yourName
 * @date 2023-02-10
 **/

#include <algorithm>
#include <cmath>
#include <climits>
#include "SnackeMotionScBlockCode.hpp"



Cell3DPosition goalPosition(1,8,0);
bool isFinish = false;

vector<Cell3DPosition> obstaclePos = {};
vector<int> obstacleIds = {};

SnackeMotionScBlockCode::SnackeMotionScBlockCode(SlidingCubesBlock *host):SlidingCubesBlockCode(host),module(host) {
    // @warning Do not remove block below, as a blockcode with a NULL host might be created
    //  for command line parsing
    if (not host) return;

    addMessageEventFunc2(GO_MSG_ID,
                       std::bind(&SnackeMotionScBlockCode::myGoFunc,this,
                       std::placeholders::_1, std::placeholders::_2));

}

void SnackeMotionScBlockCode::startup() {
    console << "start " << getId() << "\n";

    if (isLeader) { // At least one module must be "leader" in the config file
        setColor(RED);
        console << "I'm the leader!" << "\n";
        tryToMove();

    }
    if (isObstacle) { // At least one module must be "leader" in the config file
        console << "I'm an Obstacle!" << "\n";
    }
}
void SnackeMotionScBlockCode::parseUserBlockElements(TiXmlElement *config) {
    const char *attr = config->Attribute("leader");
    isLeader = (attr?Simulator::extractBoolFromString(attr):false);
    if (isLeader) {
        std::cout << getId() << " is leader!" << std::endl; // complete with your code
    }
    const char *attr1 = config->Attribute("obstacle");
    isObstacle = (attr1?Simulator::extractBoolFromString(attr1):false);
    if (isObstacle) {
        std::cout << getId() << " is Obstacle!" << std::endl; // complete with your code
        obstaclePos.push_back(module->position);
        obstacleIds.push_back(getId());
    }
}


void SnackeMotionScBlockCode::parseUserElements(TiXmlDocument *config) {
    TiXmlNode *vs = config->FirstChild("vs");
    if (!vs) return;
    TiXmlNode *node = vs->FirstChild("goal");
    if (!node) return;
    TiXmlElement *element = node->ToElement();
    const char *attr = element->Attribute("position");
    if (attr) {
        goalPosition=Simulator::extractCell3DPositionFromString(attr);
        std::cout << "goalPosition = " << goalPosition << std::endl;
    }
}

bool SnackeMotionScBlockCode::tryToMove() {
    if (module->position == goalPosition) {
        std::cout << "I'm at the goal!" << std::endl;
        isFinish = true;
        return true;
    }

    // Check neighbors for obstacles and build candidate list
    vector<P2PNetworkInterface*> to_Send;
    bool hasObstacle = false;
    for (auto neighbour : module->getP2PNetworkInterfaces()) {
        if (isItObstacle(neighbour->getConnectedBlockId())) {
            hasObstacle = true;
        } else {
            if (neighbour->getConnectedBlockId() > 0)
                to_Send.push_back(neighbour);
        }
    }
    if (to_Send.empty()) hasObstacle = false;

    // If blocked, ask neighbors to go
    if (hasObstacle) {
        for (auto neigh : to_Send) {
            sendMessage(new Message(GO_MSG_ID), neigh, 200000, 0);
            return true;
        }
    }

    // Compute possible move directions
    int y = module->position[1] < goalPosition[1] ? 1 : -1;
    Cell3DPosition position      = module->position + Cell3DPosition(0, y, 0);
    Cell3DPosition positionbis   = module->position + Cell3DPosition(0, y, -1);
    Cell3DPosition positiontris  = module->position + Cell3DPosition(0, y, 1);
    Cell3DPosition positionquad  = module->position + Cell3DPosition(0, 0, 1);
    Cell3DPosition positionquin  = module->position + Cell3DPosition(0,-1, 1);
    Cell3DPosition bottom        = module->position + Cell3DPosition(0, 0,-1);

    // if cube already aligned(in goal) on Y then slide in X
    if (module->position[1] == goalPosition[1]) {
        int x = module->position[0] > goalPosition[0] ? -1 : 1;
        position     = module->position + Cell3DPosition(x, 0, 0);
        positionbis  = module->position + Cell3DPosition(x, 0, -1);
        positiontris = module->position + Cell3DPosition(x, 0, 1);

        if (module->position[0] == goalPosition[0]) {
            // Aligned in X and Y → check Z
            if (module->getInterface(SCLattice2::Direction::MinusZ)->getConnectedBlockId() <= 0) {
                for (auto neigh : module->getP2PNetworkInterfaces()) {
                    if (!isItObstacle(neigh->getConnectedBlockId()) && neigh->getConnectedBlockId() > 0) {
                        sendMessage(new Message(GO_MSG_ID), neigh, 200000, 0);
                    }
                }
                return true;
            }
        }
    }

    // Build candidate moves in priority order
    vector<Cell3DPosition> moves = {
        goalPosition,  // try to go directly to goal
        position,      // forward in Y (or X if aligned)
        positiontris,  // forward + up
        positionbis,   // forward + down
        positionquad,  // just up
        positionquin   // back in Y + up
    };

    // If very close to the goal (within 1 step in X and Y)
    if (abs(module->position[0] - goalPosition[0]) <= 1 &&
        abs(module->position[1] - goalPosition[1]) <= 1) {

        bool canBottom = true;
        // Check that all neighbors around the bottom cell are not obstacles
        if (isItObstacle(bottom + Cell3DPosition(1,0,0)))  canBottom = false;
        if (isItObstacle(bottom + Cell3DPosition(-1,0,0))) canBottom = false;
        if (isItObstacle(bottom + Cell3DPosition(0,1,0)))  canBottom = false;
        if (isItObstacle(bottom + Cell3DPosition(0,-1,0))) canBottom = false;

        // If bottom is clear, add it as a candidate move
        if (canBottom) moves.push_back(bottom);
        }


    // Try to execute a move
    for (auto move : moves) {
        if (module->canMoveTo(move) && lastPosition != move) {
            module->moveTo(move);
            lastPosition = module->position;
            return true;
        }
    }

// tell neighbors can't move
    for (auto neigh : module->getP2PNetworkInterfaces()) {
        if (!isItObstacle(neigh->getConnectedBlockId()) && neigh->getConnectedBlockId() > 0) {
            sendMessage("I cant move here", new Message(GO_MSG_ID), neigh, 200000, 0);
        }
    }

    return false;
}

void SnackeMotionScBlockCode::onMotionEnd() {

    tryToMove();
}

/* Example of onGlDraw Function
 / which draws a 3x3x10 box in each cell of the grid.
 * This function is executed once by the first or the selected module */
void SnackeMotionScBlockCode::onGlDraw() {
    static const float thick=0.8;
    static const float color[4]={2.2f,0.2f,0.2f,1.0f};
    //const Cell3DPosition& gs = lattice->gridSize;
    const Vector3D gl = lattice->gridScale;
    glDisable(GL_TEXTURE);
    glMaterialfv(GL_FRONT,GL_AMBIENT_AND_DIFFUSE,color);
    glPushMatrix();
    glNormal3f(0,0,1);
    glScalef(gl[0],gl[1],gl[2]);
    glTranslatef(goalPosition[0],goalPosition[1],goalPosition[2]-0.49);
    glBegin(GL_QUAD_STRIP);
    for (int i=0; i<=36; i++) {
        double cs=0.5*cos(i*M_PI/18);
        double ss=0.5*sin(i*M_PI/18);
        glVertex3f(thick*cs,thick*ss,0);
        glVertex3f(cs,ss,0);
    }
    glEnd();
}

void SnackeMotionScBlockCode::myGoFunc(std::shared_ptr<Message>_msg, P2PNetworkInterface*sender) {
    int i = 0;
    // Forward the GO message to all valid neighbors (except the sender and obstacles)
    for (auto neigh : module->getP2PNetworkInterfaces()) {
        if (!isItObstacle(neigh->getConnectedBlockId()) &&
            neigh != sender &&
            neigh->getConnectedBlockId() > 0)
        {
            sendMessage(new Message(GO_MSG_ID), neigh, 200000, 0);
            i++;
            setColor(BLUE); // mark as active relay
        }
    }

    // If no neighbor to forward to, try to move ourselves
    if (i == 0) {
        // Decide Y direction (towards goal)
        int y = (module->position[1] < goalPosition[1]) ? 1 : -1;

        // Candidate moves along Y (and with Z variations)
        Cell3DPosition position        = module->position + Cell3DPosition(0, y, 0);
        Cell3DPosition positionDownZ   = module->position + Cell3DPosition(0, y, -1);
        Cell3DPosition positionUpZ     = module->position + Cell3DPosition(0, y, 1);
        Cell3DPosition positionOnlyUpZ = module->position + Cell3DPosition(0, 0, 1);
        Cell3DPosition positionBackUp  = module->position + Cell3DPosition(0, -1, 1);

        // If already aligned on Y, move in X direction (with Z variations)
        if (module->position[1] == goalPosition[1]) {
            int x = (module->position[0] > goalPosition[0]) ? -1 : 1;
            position      = module->position + Cell3DPosition(x, 0, 0);
            positionDownZ = module->position + Cell3DPosition(x, 0, -1);
            positionUpZ   = module->position + Cell3DPosition(x, 0, 1);
        }

    // Candidate moves to try, in priority order
    vector<Cell3DPosition> moves = {
        goalPosition,      // go directly to goal if possible
        positionBackUp,    // step back in Y and up in Z
        position,          // step forward in Y (or X if aligned)
        positionUpZ,       // step forward and up in Z
        positionDownZ,     // step forward and down in Z
        positionOnlyUpZ    // step only up in Z
    };

        // Try to move
    for (auto move : moves) {
          if (module->canMoveTo(move)) {
              module->moveTo(move);
              lastPosition = module->position;
              if (move == goalPosition) {
                  setColor(YELLOW); // Goal reached
              } else {
                  setColor(RED);  // Successful move
              }
              return;
          }
      }
      // If no valid moves → stuck
      setColor(ORANGE);
  }
}

string SnackeMotionScBlockCode::onInterfaceDraw(){
    if(isFinish){
        return "Goal reached!";
    }
    return "";
}

bool SnackeMotionScBlockCode::isItObstacle(int id){
    return (find(obstacleIds.begin(), obstacleIds.end(), id) != obstacleIds.end());
}
bool SnackeMotionScBlockCode::isItObstacle(Cell3DPosition pos){
    return (find(obstaclePos.begin(), obstaclePos.end(), pos) != obstaclePos.end());
}