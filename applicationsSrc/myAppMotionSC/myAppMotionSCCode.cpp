/**
 * @file myAppMotionSCCode.cpp
 * Generated by VisibleSim BlockCode Generator
 * https://services-stgi.pu-pm.univ-fcomte.fr/visiblesim/generator.php#
 * @author yourName
 * @date 2023-02-10
 **/
#include <climits>
#include <tuple>
#include "myAppMotionSCCode.hpp"


Cell3DPosition goalPosition(4,8,0);

MyAppMotionSCCode::MyAppMotionSCCode(SlidingCubesBlock *host):SlidingCubesBlockCode(host),module(host) {
    // @warning Do not remove block below, as a blockcode with a NULL host might be created
    //  for command line parsing
    if (not host) return;

    // Registers a callback (myElectFirstFunc) to the message of type L
    addMessageEventFunc2(ELECTFIRST_MSG_ID,
                       std::bind(&MyAppMotionSCCode::myElectFirstFunc,this,
                       std::placeholders::_1, std::placeholders::_2));

}

void MyAppMotionSCCode::startup() {
    console << "start " << getId() << "\n";

    if (isLeader) { // At least one module must be "leader" in the config file
        setColor(RED);
        console << "I'm the leader!" << "\n";
        tryToMove();
    }
    if (isObstacle) { // At least one module must be "leader" in the config file
        console << "I'm an Obstacle!" << "\n";
    }
}


bool MyAppMotionSCCode::tryToMove() {
    if (module->position == goalPosition) return true;

    auto motions = module->getAllMotions();
    const auto pos  = module->position;
    const auto goal = goalPosition;

    // Persist across calls (but reset when module changes)
    static Cell3DPosition lastPos = Cell3DPosition(INT_MIN, INT_MIN, INT_MIN);
    static int lastDZsign = 0; // -1 if previous move was z--, +1 if z++, 0 otherwise
    static const void* lastModulePtr = nullptr;
    if (lastModulePtr != module) {
        lastModulePtr = module;
        lastPos = Cell3DPosition(INT_MIN, INT_MIN, INT_MIN);
        lastDZsign = 0;
    }

    auto canReach    = [&](const Cell3DPosition& p){ return module->canMoveTo(p); };
    auto sameX       = [&](const Cell3DPosition& p){ return p[0] == pos[0]; };
    auto isBacktrack = [&](const Cell3DPosition& np){ return np == lastPos; };
    auto dzSign      = [&](const Cell3DPosition& np){
        int dz = np[2] - pos[2];
        return (dz > 0) ? +1 : (dz < 0 ? -1 : 0);
    };

    // --- Platform-specific neighbor check ---
    auto hasTop = [&]()->bool {
        auto top = module->getInterface(SCLattice2::Direction(2)); // usually +Z face
        return (top && top->isConnected());
    };

    auto dist = [&](const Cell3DPosition& p){
        return std::make_tuple(std::abs(p[1] - goal[1]), std::abs(p[2] - goal[2]));
    };

    auto cur = dist(pos);
    int sgnY = (goal[1] > pos[1]) ? 1 : (goal[1] < pos[1] ? -1 : 0);

    // Priority 0: exact climb (0,+1,+1), fixed X
    for (auto &m : motions) {
        const auto np = m.first;
        if (!canReach(np) || isBacktrack(np)) continue;
        if (np[0]==pos[0] && np[1]==pos[1]+1 && np[2]==pos[2]+1) {
            int dsz = dzSign(np);
            if (!(lastDZsign == -1 && dsz == -1)) { // forbid consecutive z--
                lastPos = pos;
                lastDZsign = dsz;
                module->moveTo(np);
                return true;
            }
        }
    }

    // --- NEW RULE: hasTop => try (y--, z++) ---
    if (hasTop()) {
        for (auto &m : motions) {
            const auto np = m.first;
            if (!canReach(np) || isBacktrack(np) || !sameX(np)) continue;

            int dY = np[1] - pos[1];
            int dZ = np[2] - pos[2];

            if (dY == -1 && dZ == +1) { // (y--, z++)
                lastPos = pos;
                lastDZsign = dzSign(np);
                module->moveTo(np);
                return true;
            }
        }
    }

    // Priority 1: improve Y or increase Z, keep X fixed
    std::pair<Cell3DPosition,uint8_t>* bestYZ = nullptr;
    auto bestKeyYZ = std::make_tuple(INT_MAX, INT_MAX);

    for (auto &m : motions) {
        const auto np = m.first;
        if (!canReach(np) || isBacktrack(np) || !sameX(np)) continue;

        int dY = np[1] - pos[1];
        int dZ = np[2] - pos[2];

        if (lastDZsign == -1 && dZ == -1) continue; // skip z-- if last was z--

        // Skip y++ if hasTop
        bool improvesY  = (dY != 0) && (sgnY != 0) && (np[1] == pos[1] + sgnY);
        if (improvesY && (dY == +1) && hasTop()) continue;

        bool increasesZ = (dZ > 0);
        if (!(improvesY || increasesZ)) continue;

        int dy1 = std::abs(np[1] - goal[1]);
        int preferZneg = increasesZ ? 0 : 1;
        auto key = std::make_tuple(preferZneg, dy1);
        if (key < bestKeyYZ) { bestKeyYZ = key; bestYZ = &m; }
    }

    if (bestYZ) {
        const auto np = bestYZ->first;
        if (dist(np) < cur) {
            lastPos = pos;
            lastDZsign = dzSign(np);
            module->moveTo(np);
            return true;
        }
    }

    // Priority 1.5: if no applicable +y/+z, try ONLY +z (ΔY==0, ΔZ>0), fixed X
    std::pair<Cell3DPosition,uint8_t>* bestZOnly = nullptr;
    int bestDz = INT_MAX; // minimize |z - goalZ|
    for (auto &m : motions) {
        const auto np = m.first;
        if (!canReach(np) || isBacktrack(np) || !sameX(np)) continue;
        if (np[1] != pos[1]) continue;         // ensure ΔY == 0
        int dZ = np[2] - pos[2];
        if (dZ > 0) {  // ONLY +z
            int dz1 = std::abs(np[2] - goal[2]);
            if (dz1 < bestDz) {
                bestDz = dz1;
                bestZOnly = &m;
            }
        }
    }
    if (bestZOnly) {
        const auto np = bestZOnly->first;
        lastPos = pos;
        lastDZsign = dzSign(np); // will be +1
        module->moveTo(np);
        return true;
    }

    // Last resort: strictly improve (dy,dz), keep X fixed
    for (auto &m : motions) {
        const auto np = m.first;
        if (!canReach(np) || !sameX(np)) continue;
        if (lastDZsign == -1 && (np[2] - pos[2]) == -1) continue; // forbid consecutive z--
        if (dist(np) < cur) {
            lastPos = pos;
            lastDZsign = dzSign(np);
            module->moveTo(np);
            return true;
        }
    }

    return false; // lets others proceed
}





void MyAppMotionSCCode::myElectFirstFunc(std::shared_ptr<Message>_msg, P2PNetworkInterface*sender) {

    if (isObstacle) {
        return ;
    }
    // send the message to all neighbors but the sender
    auto neighbors = sendMessageToAllNeighbors("Elect",new Message(ELECTFIRST_MSG_ID), 200000, 0,1,sender);



    if (neighbors==0) {
        setColor(RED);
        tryToMove();
    }

    else {
        setColor(BLUE);
    }

}

void MyAppMotionSCCode::parseUserBlockElements(TiXmlElement *config) {
    const char *attr = config->Attribute("leader");
    isLeader = (attr?Simulator::extractBoolFromString(attr):false);
    if (isLeader) {
        std::cout << getId() << " is leader!" << std::endl; // complete with your code
    }

    const char *attr1 = config->Attribute("obstacle");
    isObstacle = (attr1?Simulator::extractBoolFromString(attr1):false);
    if (isObstacle) {
        std::cout << getId() << " is Obstacle!" << std::endl; // complete with your code
    }
}

void MyAppMotionSCCode::onMotionEnd() {

    if (!tryToMove() && !isObstacle) {
        setColor(ORANGE);
        sendMessageToAllNeighbors("Elect", new Message(ELECTFIRST_MSG_ID), 200000, 0, 0);
    }

    // --- Check if there is a neighbor on top (+Z) ---
    // auto top = module->getInterface(SCLattice2::Direction(3)); // adjust index if needed
    // if (top && top->isConnected()) {
    //     // top neighbor detected → send election message
    //     return;

}
//SEARCH FOR BACKWARD MOVEEE

void MyAppMotionSCCode::parseUserElements(TiXmlDocument *config) {
    TiXmlNode *vs = config->FirstChild("vs");
    if (!vs) return;
    TiXmlNode *node = vs->FirstChild("goal");
    if (!node) return;
    TiXmlElement *element = node->ToElement();
    const char *attr = element->Attribute("position");
    if (attr) {
        goalPosition=Simulator::extractCell3DPositionFromString(attr);
        std::cout << "goalPosition = " << goalPosition << std::endl;
    }
}

void MyAppMotionSCCode::onGlDraw() {
    static const float thick=0.8;
    static const float color[4]={2.2f,0.2f,0.2f,1.0f};
    const Cell3DPosition& gs = lattice->gridSize;
    const Vector3D gl = lattice->gridScale;
    glDisable(GL_TEXTURE);
    glMaterialfv(GL_FRONT,GL_AMBIENT_AND_DIFFUSE,color);
    glPushMatrix();
    glNormal3f(0,0,1);
    glScalef(gl[0],gl[1],gl[2]);
    glTranslatef(goalPosition[0],goalPosition[1],goalPosition[2]-0.49);
    glBegin(GL_QUAD_STRIP);
    for (int i=0; i<=36; i++) {
        double cs=0.5*cos(i*M_PI/18);
        double ss=0.5*sin(i*M_PI/18);
        glVertex3f(thick*cs,thick*ss,0);
        glVertex3f(cs,ss,0);
    }
    glEnd();
    glPopMatrix();
}